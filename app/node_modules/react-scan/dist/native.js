'use strict';

var reactNative = require('react-native');
var reactNativeSkia = require('@shopify/react-native-skia');
var React4 = require('react');
var reactNativeReanimated = require('react-native-reanimated');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React4__namespace = /*#__PURE__*/_interopNamespace(React4);

// src/core/native/index.tsx

// src/core/instrumentation/fiber.ts
var PerformedWorkFlag = 1;
var ClassComponentTag = 1;
var FunctionComponentTag = 0;
var ContextConsumerTag = 9;
var ForwardRefTag = 11;
var MemoComponentTag = 14;
var SimpleMemoComponentTag = 15;
var HostComponentTag = 5;
var HostHoistableTag = 26;
var HostSingletonTag = 27;
var DehydratedSuspenseComponent = 18;
var HostText = 6;
var Fragment = 7;
var LegacyHiddenComponent = 23;
var OffscreenComponent = 22;
var HostRoot = 3;
var CONCURRENT_MODE_NUMBER = 60111;
var CONCURRENT_MODE_SYMBOL_STRING = "Symbol(react.concurrent_mode)";
var DEPRECATED_ASYNC_MODE_SYMBOL_STRING = "Symbol(react.async_mode)";
var traverseContexts = (fiber, selector) => {
  const nextDependencies = fiber.dependencies;
  const prevDependencies = fiber.alternate?.dependencies;
  if (!nextDependencies || !prevDependencies) return false;
  if (typeof nextDependencies !== "object" || !("firstContext" in nextDependencies) || typeof prevDependencies !== "object" || !("firstContext" in prevDependencies)) {
    return false;
  }
  let nextContext = nextDependencies.firstContext;
  let prevContext = prevDependencies.firstContext;
  while (nextContext && typeof nextContext === "object" && "memoizedValue" in nextContext && prevContext && typeof prevContext === "object" && "memoizedValue" in prevContext) {
    if (selector(nextContext, prevContext) === true) return true;
    nextContext = nextContext.next;
    prevContext = prevContext.next;
  }
  return false;
};
var traverseState = (fiber, selector) => {
  let prevState = fiber.memoizedState;
  let nextState = fiber.alternate?.memoizedState;
  while (prevState && nextState) {
    if (selector(prevState, nextState) === true) return true;
    prevState = prevState.next;
    nextState = nextState.next;
  }
  return false;
};
var isHostComponent = (fiber) => fiber.tag === HostComponentTag || // @ts-expect-error: it exists
fiber.tag === HostHoistableTag || // @ts-expect-error: it exists
fiber.tag === HostSingletonTag;
var didFiberRender = (fiber) => {
  const nextProps = fiber.memoizedProps;
  const prevProps = fiber.alternate?.memoizedProps || {};
  const flags = fiber.flags ?? fiber.effectTag ?? 0;
  switch (fiber.tag) {
    case ClassComponentTag:
    case FunctionComponentTag:
    case ContextConsumerTag:
    case ForwardRefTag:
    case MemoComponentTag:
    case SimpleMemoComponentTag: {
      return (flags & PerformedWorkFlag) === PerformedWorkFlag;
    }
    default:
      if (!fiber.alternate) return true;
      return prevProps !== nextProps || fiber.alternate.memoizedState !== fiber.memoizedState || fiber.alternate.ref !== fiber.ref;
  }
};
var shouldFilterFiber = (fiber) => {
  switch (fiber.tag) {
    case DehydratedSuspenseComponent:
      return true;
    case HostText:
    case Fragment:
    case LegacyHiddenComponent:
    case OffscreenComponent:
      return true;
    case HostRoot:
      return false;
    default: {
      const symbolOrNumber = typeof fiber.type === "object" && fiber.type !== null ? fiber.type.$$typeof : fiber.type;
      const typeSymbol = typeof symbolOrNumber === "symbol" ? symbolOrNumber.toString() : symbolOrNumber;
      switch (typeSymbol) {
        case CONCURRENT_MODE_NUMBER:
        case CONCURRENT_MODE_SYMBOL_STRING:
        case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
          return true;
        default:
          return false;
      }
    }
  }
};
var getNearestHostFiber = (fiber) => {
  let hostFiber = traverseFiber(fiber, isHostComponent);
  if (!hostFiber) {
    hostFiber = traverseFiber(fiber, isHostComponent, true);
  }
  return hostFiber;
};
var traverseFiber = (fiber, selector, ascending = false) => {
  if (!fiber) return null;
  if (selector(fiber) === true) return fiber;
  let child = ascending ? fiber.return : fiber.child;
  while (child) {
    const match = traverseFiber(child, selector, ascending);
    if (match) return match;
    child = ascending ? null : child.sibling;
  }
  return null;
};
var getSelfTime = (fiber) => {
  const totalTime = fiber?.actualDuration ?? 0;
  let selfTime = totalTime;
  let child = fiber?.child ?? null;
  while (totalTime > 0 && child != null) {
    selfTime -= child.actualDuration ?? 0;
    child = child.sibling;
  }
  return selfTime;
};
var hasMemoCache = (fiber) => {
  return Boolean(fiber.updateQueue?.memoCache);
};

// src/core/instrumentation/init.ts
var NO_OP = () => {
};
var registerDevtoolsHook = ({
  onCommitFiberRoot
}) => {
  let devtoolsHook = globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  const renderers = /* @__PURE__ */ new Map();
  let i = 0;
  if (!devtoolsHook) {
    devtoolsHook = {
      checkDCE: NO_OP,
      supportsFiber: true,
      renderers,
      onScheduleFiberRoot: NO_OP,
      onCommitFiberRoot: NO_OP,
      onCommitFiberUnmount: NO_OP,
      inject(renderer) {
        const nextID = ++i;
        renderers.set(nextID, renderer);
        return nextID;
      }
    };
    globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__ = devtoolsHook;
  }
  const prevOnCommitFiberRoot = devtoolsHook.onCommitFiberRoot;
  devtoolsHook.onCommitFiberRoot = (rendererID, root) => {
    if (prevOnCommitFiberRoot) prevOnCommitFiberRoot(rendererID, root);
    onCommitFiberRoot(rendererID, root);
  };
  return devtoolsHook;
};
registerDevtoolsHook({
  onCommitFiberRoot() {
  }
});

// src/core/utils.ts
var getLabelText = (renders, env) => {
  let labelText = "";
  const components = /* @__PURE__ */ new Map();
  for (let i = 0, len = renders.length; i < len; i++) {
    const render = renders[i];
    const name = render.name;
    if (!name?.trim()) continue;
    const { count, trigger, forget } = components.get(name) ?? {
      count: 0,
      trigger: false,
      forget: false
    };
    components.set(name, {
      count: count + render.count,
      trigger: trigger || render.trigger,
      forget: forget || render.forget
    });
  }
  const sortedComponents = Array.from(components.entries()).sort(
    ([, a], [, b]) => b.count - a.count
  );
  const parts = [];
  for (const [name, { count, forget }] of sortedComponents) {
    let text = name;
    if (count > 1) {
      text += ` \xD7${count}`;
    }
    parts.push(text);
  }
  labelText = parts.join(" ");
  if (!labelText.length) return null;
  if (labelText.length > 20) {
    labelText = `${labelText.slice(0, 20)}\u2026`;
  }
  return labelText;
};
var getCopiedActiveOutlines = () => [
  ...ReactScanInternals.activeOutlines
];

// src/core/web/outline.ts
var genId = () => {
  const timeStamp = performance.now();
  const randomNum = Math.floor(Math.random() * 1e3);
  return `${timeStamp}-${randomNum}`;
};

// src/core/web/inspect-element/utils.ts
var isCompositeComponent = (fiber) => {
  return fiber.tag === FunctionComponentTag || fiber.tag === ClassComponentTag || fiber.tag === SimpleMemoComponentTag || fiber.tag === MemoComponentTag;
};
var fastSerialize = (value) => {
  switch (typeof value) {
    case "function":
      return value.toString();
    case "string":
      return value;
    case "object":
      if (value === null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return value.length > 0 ? "[\u2026]" : "[]";
      }
      if (React4__namespace.isValidElement(value) && "$$typeof" in value && typeof value.$$typeof === "symbol" && String(value.$$typeof) === "Symbol(react.element)") {
        return `<${getDisplayName(value.type) ?? ""}${Object.keys(value.props || {}).length > 0 ? " \u2026" : ""}>`;
      }
      if (typeof value === "object" && value !== null && value.constructor === Object) {
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            return "{\u2026}";
          }
        }
        return "{}";
      }
      const tagString = Object.prototype.toString.call(value).slice(8, -1);
      if (tagString === "Object") {
        const proto = Object.getPrototypeOf(value);
        const constructor = proto?.constructor;
        if (typeof constructor === "function") {
          return `${constructor.displayName || constructor.name || ""}{\u2026}`;
        }
      }
      return `${tagString}{\u2026}`;
    default:
      return String(value);
  }
};
var getType = (type) => {
  if (typeof type === "function") {
    return type;
  }
  if (typeof type === "object" && type) {
    return getType(type.type || type.render);
  }
  return null;
};
var getDisplayName = (type) => {
  const name = type.displayName || type.name || null;
  if (name) return name;
  type = getType(type);
  if (!type) return null;
  return type.displayName || type.name || null;
};

// src/core/instrumentation/index.ts
var unstableTypes = ["function", "object"];
var getPropsRender = (fiber, type) => {
  const changes = [];
  const prevProps = fiber.alternate?.memoizedProps;
  const nextProps = fiber.memoizedProps;
  for (const propName in { ...prevProps, ...nextProps }) {
    const prevValue = prevProps?.[propName];
    const nextValue = nextProps?.[propName];
    if (Object.is(prevValue, nextValue) || React4__namespace.isValidElement(prevValue) || React4__namespace.isValidElement(nextValue) || propName === "children") {
      continue;
    }
    const change = {
      name: propName,
      prevValue,
      nextValue,
      unstable: false
    };
    changes.push(change);
    const prevValueString = fastSerialize(prevValue);
    const nextValueString = fastSerialize(nextValue);
    if (!unstableTypes.includes(typeof prevValue) || !unstableTypes.includes(typeof nextValue) || prevValueString !== nextValueString) {
      continue;
    }
    change.unstable = true;
  }
  return {
    type: "props",
    count: 1,
    trigger: false,
    changes,
    name: getDisplayName(type),
    time: getSelfTime(fiber),
    forget: hasMemoCache(fiber)
  };
};
var getContextRender = (fiber, type) => {
  const changes = [];
  const result = traverseContexts(fiber, (prevContext, nextContext) => {
    const prevValue = prevContext.memoizedValue;
    const nextValue = nextContext.memoizedValue;
    const change = {
      name: "",
      prevValue,
      nextValue,
      unstable: false
    };
    changes.push(change);
    const prevValueString = fastSerialize(prevValue);
    const nextValueString = fastSerialize(nextValue);
    if (unstableTypes.includes(typeof prevValue) && unstableTypes.includes(typeof nextValue) && prevValueString === nextValueString) {
      change.unstable = true;
    }
  });
  if (!result) return null;
  return {
    type: "context",
    count: 1,
    trigger: false,
    changes,
    name: getDisplayName(type),
    time: getSelfTime(fiber),
    forget: hasMemoCache(fiber)
  };
};
var reportRender = (name, fiber, renders) => {
  if (ReactScanInternals.options.report === false) return;
  const report = ReactScanInternals.reportData[name];
  if (report) {
    for (let i = 0, len = renders.length; i < len; i++) {
      const render = renders[i];
      if (render) {
        report.badRenders.push(render);
      }
    }
  }
  const time = getSelfTime(fiber) ?? 0;
  ReactScanInternals.reportData[name] = {
    count: (report?.count ?? 0) + 1,
    time: (report?.time ?? 0) + time,
    badRenders: report?.badRenders || [],
    type: getType(fiber.type) || fiber.type
  };
};
var reportRenderFiber = (fiber, renders) => {
  const [reportFiber, report] = (() => {
    const currentFiberData = ReactScanInternals.reportDataByFiber.get(fiber);
    if (currentFiberData) {
      return [fiber, currentFiberData];
    }
    if (!fiber.alternate) {
      return [fiber, null];
    }
    const alternateFiberData = ReactScanInternals.reportDataByFiber.get(
      fiber.alternate
    );
    return [fiber.alternate, alternateFiberData];
  })();
  if (report) {
    for (let i = 0, len = renders.length; i < len; i++) {
      const render = renders[i];
      if (render) {
        report.badRenders.push(render);
      }
    }
  }
  const time = getSelfTime(fiber);
  ReactScanInternals.reportDataByFiber.set(reportFiber, {
    count: (report?.count ?? 0) + 1,
    time: (report?.time ?? 0) + (time !== 0 ? time : 0.1),
    // .1ms lowest precision
    badRenders: report?.badRenders ?? [],
    displayName: getDisplayName(fiber)
  });
  ReactScanInternals.emit(
    "reportDataByFiber",
    ReactScanInternals.reportDataByFiber
  );
};
var instrument = ({
  onCommitStart,
  onRender,
  onCommitFinish
}) => {
  const handleCommitFiberRoot = (_rendererID, root) => {
    if (ReactScanInternals.isPaused && ReactScanInternals.inspectState.kind === "inspect-off" || ReactScanInternals.options.enabled === false) {
      return;
    }
    onCommitStart();
    const recordRender = (fiber) => {
      const type = getType(fiber.type);
      if (!type) return null;
      if (!didFiberRender(fiber)) return null;
      const propsRender = getPropsRender(fiber, type);
      const contextRender = getContextRender(fiber, type);
      let trigger = false;
      if (fiber.alternate) {
        const didStateChange = traverseState(fiber, (prevState, nextState) => {
          return !Object.is(prevState.memoizedState, nextState.memoizedState);
        });
        if (didStateChange) {
          trigger = true;
        }
      }
      const name = getDisplayName(type);
      if (name === "Million(Profiler)") return;
      if (name) {
        reportRender(name, fiber, [propsRender, contextRender]);
      }
      if (isCompositeComponent(fiber)) {
        reportRenderFiber(fiber, [propsRender, contextRender]);
      }
      if (!propsRender && !contextRender) return null;
      const allowList = ReactScanInternals.componentAllowList;
      const shouldAllow = allowList?.has(fiber.type) ?? allowList?.has(fiber.elementType);
      if (shouldAllow) {
        const parent = traverseFiber(
          fiber,
          (node) => {
            const options = allowList?.get(node.type) ?? allowList?.get(node.elementType);
            return options?.includeChildren;
          },
          true
        );
        if (!parent && !shouldAllow) return null;
      }
      if (propsRender) {
        propsRender.trigger = trigger;
        onRender(fiber, propsRender);
      }
      if (contextRender) {
        contextRender.trigger = trigger;
        onRender(fiber, contextRender);
      }
      if (trigger) {
        onRender(fiber, {
          type: "state",
          count: 1,
          trigger,
          changes: [],
          name: getDisplayName(type),
          time: getSelfTime(fiber),
          forget: hasMemoCache(fiber)
        });
      }
      if (!propsRender && !contextRender && !trigger) {
        onRender(fiber, {
          type: "misc",
          count: 1,
          trigger,
          changes: [],
          name: getDisplayName(type),
          time: getSelfTime(fiber),
          forget: hasMemoCache(fiber)
        });
      }
    };
    const rootFiber = root.current;
    const wasMounted = rootFiber.alternate !== null && Boolean(rootFiber.alternate.memoizedState?.element) && // A dehydrated root is not considered mounted
    rootFiber.alternate.memoizedState.isDehydrated !== true;
    const isMounted = Boolean(rootFiber.memoizedState?.element);
    const mountFiber = (firstChild, traverseSiblings) => {
      let fiber = firstChild;
      while (fiber != null) {
        const shouldIncludeInTree = !shouldFilterFiber(fiber);
        if (shouldIncludeInTree) {
          recordRender(fiber);
        }
        if (fiber.child != null) {
          mountFiber(fiber.child, true);
        }
        fiber = traverseSiblings ? fiber.sibling : null;
      }
    };
    const updateFiber = (nextFiber, prevFiber) => {
      if (!prevFiber) return;
      const shouldIncludeInTree = !shouldFilterFiber(nextFiber);
      if (shouldIncludeInTree) {
        recordRender(nextFiber);
      }
      if (nextFiber.child !== prevFiber.child) {
        let nextChild = nextFiber.child;
        while (nextChild) {
          const prevChild = nextChild.alternate;
          if (prevChild) {
            updateFiber(nextChild, prevChild);
          } else {
            mountFiber(nextChild, false);
          }
          nextChild = nextChild.sibling;
        }
      }
    };
    if (!wasMounted && isMounted) {
      mountFiber(rootFiber, false);
    } else if (wasMounted && isMounted) {
      updateFiber(rootFiber, rootFiber.alternate);
    }
    onCommitFinish();
  };
  ReactScanInternals.onCommitFiberRoot = (rendererID, root) => {
    if (root) {
      ReactScanInternals.fiberRoots.add(root);
    }
    try {
      handleCommitFiberRoot(rendererID, root);
    } catch (err) {
      console.error("[React Scan] Error instrumenting: ", err);
    }
  };
  registerDevtoolsHook({
    onCommitFiberRoot: ReactScanInternals.onCommitFiberRoot
  });
};

// src/core/index.ts
var createStore = (initialData) => {
  const data = { ...initialData };
  const listeners = {};
  const emit = (key, value) => {
    listeners[key]?.forEach((listener) => listener(value));
  };
  const set = (key, value) => {
    if (data[key] !== value) {
      data[key] = value;
      emit(key, value);
    }
  };
  const subscribe = (key, listener) => {
    if (!listeners[key]) {
      listeners[key] = [];
    }
    listeners[key].push(listener);
    listener(data[key]);
    return () => {
      listeners[key] = listeners[key].filter((l) => l !== listener);
    };
  };
  const setState = (state) => {
    for (const key in state) {
      if (Object.prototype.hasOwnProperty.call(state, key)) {
        set(key, state[key]);
      }
    }
  };
  const subscribeMultiple = (subscribeTo, listener) => {
    subscribeTo.forEach((key) => {
      if (!listeners[key]) {
        listeners[key] = [];
      }
      listeners[key]?.push(() => listener(data));
    });
    return () => {
      subscribeTo.forEach((key) => {
        listeners[key] = listeners[key]?.filter((cb) => cb !== listener);
      });
    };
  };
  const proxy = new Proxy(data, {
    get(target, prop, receiver) {
      if (prop === "subscribe") return subscribe;
      if (prop === "setState") return setState;
      if (prop === "emit") return emit;
      if (prop === "set") return set;
      if (prop === "subscribeMultiple") return subscribeMultiple;
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value) {
      if (prop in target) {
        set(prop, value);
        return true;
      }
      throw new Error(`Property "${String(prop)}" does not exist`);
    },
    deleteProperty(_, prop) {
      throw new Error(`Cannot delete property "${String(prop)}" from store`);
    }
  });
  return proxy;
};
var tryParse = (x) => {
  try {
    return JSON.parse(x);
  } catch {
    return "false";
  }
};
var ReactScanInternals = createStore({
  onCommitFiberRoot: (_rendererID, _root) => {
  },
  isInIframe: typeof window !== "undefined" && window.self !== window.top,
  isPaused: typeof localStorage === "undefined" ? false : tryParse(localStorage.getItem("react-scan-paused") ?? "false"),
  componentAllowList: null,
  options: {
    enabled: true,
    includeChildren: true,
    playSound: false,
    log: false,
    showToolbar: true,
    renderCountThreshold: 0,
    report: void 0,
    alwaysShowLabels: false,
    animationSpeed: "fast"
  },
  onRender: null,
  reportData: {},
  reportDataByFiber: /* @__PURE__ */ new WeakMap(),
  scheduledOutlines: [],
  activeOutlines: [],
  fiberRoots: /* @__PURE__ */ new WeakSet(),
  inspectState: {
    kind: "uninitialized"
  }
});
var measurementCache = /* @__PURE__ */ new WeakMap();
var pendingCount = 0;
var MAX_PENDING = 50;
var queue = [];
var processQueue = () => {
  if (pendingCount >= MAX_PENDING || queue.length === 0) {
    return;
  }
  const { fiber, callback, resolve } = queue.shift();
  pendingCount++;
  const handleMeasurement = (x, y, width, height, pageX, pageY) => {
    const coords = { width, height, pageX, pageY, x, y };
    measurementCache.set(fiber, {
      measurement: coords,
      timestamp: Date.now()
    });
    if (fiber.alternate) {
      measurementCache.set(fiber.alternate, {
        measurement: coords,
        timestamp: Date.now()
      });
    }
    callback?.(coords);
    resolve(coords);
    pendingCount--;
    processQueue();
  };
  const executeMeasurement = () => {
    const now = Date.now();
    const cached = measurementCache.get(fiber);
    if (cached && now - cached.timestamp < 250) {
      callback?.(cached.measurement);
      resolve(cached.measurement);
      pendingCount--;
      processQueue();
      return;
    }
    let measurableNode = fiber;
    while (measurableNode) {
      if (measurableNode.stateNode?.canonical?.nativeTag) {
        reactNative.UIManager.measure(
          measurableNode.stateNode.canonical.nativeTag,
          handleMeasurement
        );
        return;
      }
      if (measurableNode.stateNode?._nativeTag) {
        reactNative.UIManager.measure(
          measurableNode.stateNode._nativeTag,
          handleMeasurement
        );
        return;
      }
      if (measurableNode.stateNode?.measureInWindow) {
        measurableNode.stateNode.measureInWindow(
          (x, y, width, height) => {
            handleMeasurement(x, y, width, height, x, y);
          }
        );
        return;
      }
      measurableNode = measurableNode.child;
    }
    callback?.(null);
    resolve(null);
    pendingCount--;
    processQueue();
  };
  executeMeasurement();
};
var measureFiber = (fiber, callback) => {
  return new Promise((resolve) => {
    queue.push({ fiber, callback, resolve });
    processQueue();
  });
};
var getKey = (measurement) => {
  return `${measurement.pageX}-${measurement.pageY}-${measurement.width}-${measurement.height}`;
};
var assertNative = (measurement) => {
  if (measurement.kind !== "native") {
    throw new Error("native invariant");
  }
  return measurement;
};
var updateOutlines = async (fiber, render) => {
  const hostFiber = getNearestHostFiber(fiber);
  if (!hostFiber) {
    return null;
  }
  const measurement = await measureFiber(fiber);
  if (!measurement) {
    return null;
  }
  if (!measurement.pageX) {
    return null;
  }
  try {
    const existingOutline = ReactScanInternals.activeOutlines.find(
      ({ outline }) => {
        return getKey(assertNative(outline.latestMeasurement).value) === getKey(measurement);
      }
    );
    if (existingOutline) {
      existingOutline.outline.renders.push(render);
      existingOutline.text = getLabelText(
        existingOutline.outline.renders,
        "native"
      );
      existingOutline.updatedAt = Date.now();
      ReactScanInternals.activeOutlines = getCopiedActiveOutlines();
    } else {
      const newOutline = {
        latestMeasurement: {
          kind: "native",
          value: measurement
        },
        fiber,
        renders: [render]
      };
      ReactScanInternals.activeOutlines.push({
        outline: newOutline,
        id: genId(),
        resolve: () => {
        },
        text: getLabelText(newOutline.renders, "native"),
        updatedAt: Date.now(),
        // these are not used/needed in native. We should make activeOutlines
        // a discriminated union to avoid this hack
        alpha: -1,
        frame: -1,
        totalFrames: -1
      });
      ReactScanInternals.activeOutlines = getCopiedActiveOutlines();
    }
  } catch (e) {
    console.log(e);
  }
};
var instrumentNative = () => {
  const options = ReactScanInternals.options;
  instrument({
    onCommitStart() {
      options.onCommitStart?.();
    },
    async onRender(fiber, render) {
      options.onRender?.(fiber, render);
      updateOutlines(fiber, render);
    },
    onCommitFinish() {
      options.onCommitFinish?.();
    }
  });
};

// src/core/native/index.tsx
var useIsPaused = () => {
  const [isPaused, setIsPaused] = React4.useState(ReactScanInternals.isPaused);
  React4.useEffect(() => {
    ReactScanInternals.subscribe(
      "isPaused",
      (isPaused2) => setIsPaused(isPaused2)
    );
  }, []);
  return isPaused;
};
var OptionsContext = React4.createContext({
  animationWhenFlashing: false
});
var defaultOptions = {
  alwaysShowLabels: false,
  animationWhenFlashing: false,
  enabled: true,
  log: false,
  maxRenders: 20,
  renderCountThreshold: 0,
  report: false,
  resetCountTimeout: 5e3,
  showToolbar: true
};
var ReactScan = (props) => {
  if (process.env.NODE_ENV === "production" || !__DEV__) {
    return props.children;
  }
  return /* @__PURE__ */ React4__namespace.default.createElement(ReactScanEntry, { ...props });
};
var ReactScanEntry = ({
  children,
  options = defaultOptions
}) => {
  const withDefaultOptions = React4.useMemo(
    () => ({ ...defaultOptions, ...options }),
    [options]
  );
  React4.useEffect(() => {
    ReactScanInternals.options = withDefaultOptions;
    ReactScanInternals.isPaused = !withDefaultOptions.enabled;
    instrumentNative();
  }, [withDefaultOptions]);
  const isPaused = useIsPaused();
  React4.useEffect(() => {
    const interval = setInterval(() => {
      if (isPaused) return;
      const newActive = ReactScanInternals.activeOutlines.filter(
        (x) => Date.now() - x.updatedAt < 500
      );
      if (newActive.length !== ReactScanInternals.activeOutlines.length) {
        ReactScanInternals.set("activeOutlines", newActive);
      }
    }, 200);
    return () => {
      clearInterval(interval);
    };
  }, [isPaused]);
  if (!withDefaultOptions.enabled) {
    return children;
  }
  return /* @__PURE__ */ React4__namespace.default.createElement(React4__namespace.default.Fragment, null, children, /* @__PURE__ */ React4__namespace.default.createElement(OptionsContext.Provider, { value: withDefaultOptions }, !isPaused && /* @__PURE__ */ React4__namespace.default.createElement(ReactScanCanvas, { scanTag: "react-scan-no-traverse" }), withDefaultOptions.showToolbar && /* @__PURE__ */ React4__namespace.default.createElement(
    ReactScanToolbar,
    {
      scanTag: "react-scan-no-traverse",
      isPaused
    }
  )));
};
var ReactScanToolbar = ({
  isPaused
}) => {
  const pan = React4.useRef(new reactNative.Animated.ValueXY()).current;
  const panResponder = React4.useRef(
    reactNative.PanResponder.create({
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => {
        pan.setOffset({
          // @ts-expect-error its fine...
          x: pan.x._value,
          // @ts-expect-error its fine...
          y: pan.y._value
        });
      },
      onPanResponderMove: reactNative.Animated.event([null, { dx: pan.x, dy: pan.y }], {
        useNativeDriver: false
      }),
      onPanResponderRelease: () => {
        pan.flattenOffset();
      }
    })
  ).current;
  return /* @__PURE__ */ React4__namespace.default.createElement(
    reactNative.Animated.View,
    {
      id: "react-scan-no-traverse",
      style: {
        position: "absolute",
        bottom: 20,
        right: 20,
        zIndex: 999999,
        transform: pan.getTranslateTransform()
      },
      ...panResponder.panHandlers
    },
    /* @__PURE__ */ React4__namespace.default.createElement(
      reactNative.Pressable,
      {
        onPress: () => ReactScanInternals.isPaused = !ReactScanInternals.isPaused,
        style: {
          backgroundColor: "rgba(0,0,0,1)",
          paddingHorizontal: 12,
          paddingVertical: 6,
          borderRadius: 4,
          flexDirection: "row",
          alignItems: "center",
          gap: 8
        }
      },
      /* @__PURE__ */ React4__namespace.default.createElement(
        reactNative.View,
        {
          style: {
            width: 8,
            height: 8,
            borderRadius: 4,
            backgroundColor: !isPaused ? "#4ADE80" : "#666"
          }
        }
      ),
      /* @__PURE__ */ React4__namespace.default.createElement(
        reactNative.Text,
        {
          style: {
            color: "white",
            fontSize: 14,
            fontWeight: "bold",
            fontFamily: reactNative.Platform.select({
              ios: "Courier",
              default: "monospace"
            })
          }
        },
        "React Scan"
      )
    )
  );
};
var dimensions = reactNative.Dimensions.get("window");
var isVisible = (x, y) => {
  return x >= 0 && x <= dimensions.width && y >= 0 && y <= dimensions.height;
};
var font = reactNativeSkia.matchFont({
  fontFamily: reactNative.Platform.select({ ios: "Courier", default: "monospace" }),
  fontSize: 11,
  fontWeight: "bold"
});
var getTextWidth = (text) => {
  return (text || "unknown").length * 7;
};
var useOutlines = (opacity) => {
  const [outlines, setOutlines] = React4.useState([]);
  const options = React4.useContext(OptionsContext);
  React4.useEffect(() => {
    ReactScanInternals.subscribe("activeOutlines", (activeOutlines) => {
      setOutlines(activeOutlines);
      if (options.animationWhenFlashing !== false) {
        opacity.value = 1;
        opacity.value = reactNativeReanimated.withTiming(0, {
          duration: 500
        });
      }
    });
  }, []);
  return outlines;
};
var ReactScanCanvas = (_) => {
  const opacity = reactNativeReanimated.useSharedValue(1);
  const outlines = useOutlines(opacity);
  return /* @__PURE__ */ React4__namespace.default.createElement(
    reactNativeSkia.Canvas,
    {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: dimensions.width,
        height: dimensions.height,
        zIndex: 999999,
        pointerEvents: "none"
      }
    },
    /* @__PURE__ */ React4__namespace.default.createElement(reactNativeSkia.Group, { opacity }, outlines.filter(({ outline }) => {
      const measurement = assertNative(outline.latestMeasurement).value;
      const vis = isVisible(measurement.x, measurement.y);
      return vis;
    }).map((render) => {
      const textWidth = getTextWidth(render.text ?? "unknown");
      const labelPadding = 4;
      const labelWidth = textWidth + labelPadding * 2;
      const labelHeight = 12;
      return /* @__PURE__ */ React4__namespace.default.createElement(reactNativeSkia.Group, { key: render.id }, /* @__PURE__ */ React4__namespace.default.createElement(
        reactNativeSkia.Rect,
        {
          x: assertNative(render.outline.latestMeasurement).value.pageX,
          y: assertNative(render.outline.latestMeasurement).value.pageY,
          width: assertNative(render.outline.latestMeasurement).value.width,
          height: assertNative(render.outline.latestMeasurement).value.height,
          color: "rgba(88, 82, 185, 0.1)"
        }
      ), /* @__PURE__ */ React4__namespace.default.createElement(
        reactNativeSkia.Rect,
        {
          x: assertNative(render.outline.latestMeasurement).value.pageX,
          y: assertNative(render.outline.latestMeasurement).value.pageY,
          width: assertNative(render.outline.latestMeasurement).value.width,
          height: assertNative(render.outline.latestMeasurement).value.height,
          color: "rgba(147, 141, 255, 0.6)",
          style: "stroke",
          strokeWidth: 1
        }
      ), /* @__PURE__ */ React4__namespace.default.createElement(
        reactNativeSkia.Rect,
        {
          x: assertNative(render.outline.latestMeasurement).value.pageX,
          y: assertNative(render.outline.latestMeasurement).value.pageY - labelHeight - 2,
          width: labelWidth,
          height: labelHeight,
          color: "rgba(88, 82, 185, 0.9)"
        }
      ), /* @__PURE__ */ React4__namespace.default.createElement(
        reactNativeSkia.Text,
        {
          x: assertNative(render.outline.latestMeasurement).value.pageX + labelPadding,
          y: assertNative(render.outline.latestMeasurement).value.pageY - 5,
          text: render.text || "unknown",
          font,
          color: "#FFFFFF"
        }
      ));
    }))
  );
};

exports.ReactScan = ReactScan;
