'use strict';

var child_process = require('child_process');
var playwright = require('playwright');
var mri = require('mri');
var prompts = require('@clack/prompts');
var kleur = require('kleur');
var fs = require('fs');
var path = require('path');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var mri__default = /*#__PURE__*/_interopDefault(mri);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);

// src/cli.mts
var truncateString = (str, maxLength) => {
  str = str.replace("http://", "").replace("https://", "").replace("www.", "");
  if (str.endsWith("/")) {
    str = str.slice(0, -1);
  }
  if (str.length > maxLength) {
    const half = Math.floor(maxLength / 2);
    const start = str.slice(0, half);
    const end = str.slice(str.length - (maxLength - half));
    return start + "\u2026" + end;
  }
  return str;
};
var inferValidURL = (maybeURL) => {
  try {
    return new URL(maybeURL).href;
  } catch {
    try {
      return new URL(`https://${maybeURL}`).href;
    } catch {
      return "about:blank";
    }
  }
};
var getBrowserDetails = async (browserType) => {
  switch (browserType) {
    case "firefox":
      return { browserType: playwright.firefox, channel: void 0, name: "firefox" };
    case "webkit":
      return { browserType: playwright.webkit, channel: void 0, name: "webkit" };
    default:
      return { browserType: playwright.chromium, channel: "chrome", name: "chrome" };
  }
};
var userAgentStrings = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.2227.0 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.3497.92 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36"
];
var applyStealthScripts = async (context) => {
  await context.addInitScript(() => {
    Object.defineProperty(navigator, "webdriver", {
      get: () => void 0
    });
    Object.defineProperty(navigator, "languages", {
      get: () => ["en-US", "en"]
    });
    Object.defineProperty(navigator, "plugins", {
      get: () => [1, 2, 3, 4, 5]
    });
    delete window.__playwright;
    delete window.__pw_manual;
    delete window.__PW_inspect;
    Object.defineProperty(navigator, "headless", {
      get: () => false
    });
    const originalQuery = window.navigator.permissions.query;
    window.navigator.permissions.query = (parameters) => parameters.name === "notifications" ? Promise.resolve({
      state: Notification.permission
    }) : originalQuery(parameters);
  });
};
var init = async () => {
  prompts.intro(`${kleur.bgMagenta("[\xB7]")} React Scan`);
  const args = mri__default.default(process.argv.slice(2));
  let browser;
  const device = playwright.devices[args.device];
  const { browserType, channel } = await getBrowserDetails(args.browser);
  const contextOptions = {
    headless: false,
    channel,
    ...device,
    acceptDownloads: true,
    viewport: null,
    locale: "en-US",
    timezoneId: "America/New_York",
    args: [
      "--enable-webgl",
      "--use-gl=swiftshader",
      "--enable-accelerated-2d-canvas",
      "--disable-blink-features=AutomationControlled",
      "--disable-web-security"
    ],
    userAgent: userAgentStrings[Math.floor(Math.random() * userAgentStrings.length)],
    bypassCSP: true
  };
  try {
    browser = await browserType.launch({
      headless: false,
      channel
    });
  } catch {
  }
  if (!browser) {
    try {
      browser = await browserType.launch({ headless: false });
    } catch {
      await new Promise(async (resolve, reject) => {
        const shouldInstall = await prompts.confirm({
          message: "No drivers found. Install Playwright Chromium driver to continue?"
        });
        if (prompts.isCancel(shouldInstall)) {
          prompts.cancel("Operation cancelled.");
          process.exit(0);
        }
        if (!shouldInstall) return process.exit(0);
        const installProcess = child_process.spawn(
          "npx",
          ["playwright@latest", "install", "chromium"],
          { stdio: "inherit" }
        );
        installProcess.on("close", (code) => {
          if (!code) return resolve();
          reject(new Error(`Installation process exited with code ${code}`));
        });
        installProcess.on("error", (err) => {
          reject(err);
        });
      });
      try {
        browser = await playwright.chromium.launch({ headless: false });
      } catch {
        prompts.cancel(
          "No browser could be launched. Please run `npx playwright install` to install browser drivers."
        );
      }
    }
  }
  if (!browser) {
    prompts.cancel(
      "No browser could be launched. Please run `npx playwright install` to install browser drivers."
    );
    return;
  }
  const context = await browser.newContext(contextOptions);
  await applyStealthScripts(context);
  await context.addInitScript({
    content: `(() => {
      const NO_OP = () => {};
      let i = 0;
      globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {
        checkDCE: NO_OP,
        supportsFiber: true,
        renderers: new Map(),
        onScheduleFiberRoot: NO_OP,
        onCommitFiberRoot: NO_OP,
        onCommitFiberUnmount: NO_OP,
        inject(renderer) {
          const nextID = ++i;
          this.renderers.set(nextID, renderer);
          return nextID;
        },
      };
    })();`
  });
  const page = await context.newPage();
  const scriptContent = fs__default.default.readFileSync(
    path__default.default.resolve(__dirname, "./auto.global.js"),
    "utf8"
  );
  const inputUrl = args._[0] || "about:blank";
  const urlString = inferValidURL(inputUrl);
  await page.goto(urlString);
  await page.waitForLoadState("load");
  await page.waitForTimeout(500);
  await page.addScriptTag({
    content: `${scriptContent}
//# sourceURL=react-scan.js`
  });
  const pollReport = async () => {
    if (page.url() !== currentURL) return;
    await page.evaluate(() => {
      const globalHook = globalThis.__REACT_SCAN__;
      if (!globalHook) return;
      const reportData = globalHook.ReactScanInternals.reportData;
      if (!Object.keys(reportData).length) return;
      let count2 = 0;
      for (const componentName in reportData) {
        count2 += reportData[componentName].count;
      }
      console.log("REACT_SCAN_REPORT", count2);
    });
  };
  let count = 0;
  let currentSpinner;
  let currentURL = urlString;
  let interval;
  const inject = async (url) => {
    if (interval) clearInterval(interval);
    currentURL = url;
    const truncatedURL = truncateString(url, 50);
    currentSpinner?.stop(`${truncatedURL}${count ? ` (\xD7${count})` : ""}`);
    currentSpinner = prompts.spinner();
    currentSpinner.start(kleur.dim(`Scanning: ${truncatedURL}`));
    count = 0;
    try {
      await page.waitForLoadState("load");
      await page.waitForTimeout(500);
      const hasReactScan = await page.evaluate(() => {
        return Boolean(globalThis.__REACT_SCAN__);
      });
      if (!hasReactScan) {
        await page.addScriptTag({
          content: scriptContent
        });
      }
      await page.waitForTimeout(100);
      await page.evaluate(() => {
        if (typeof globalThis.reactScan !== "function") return;
        globalThis.reactScan({ report: true });
        globalThis.__REACT_SCAN__.ReactScanInternals.reportData = {};
      });
      interval = setInterval(() => {
        pollReport().catch(() => {
        });
      }, 1e3);
    } catch (e) {
      currentSpinner?.stop(kleur.red(`Error: ${truncatedURL}`));
    }
  };
  await inject(urlString);
  page.on("framenavigated", async (frame) => {
    if (frame !== page.mainFrame()) return;
    const url = frame.url();
    inject(url);
  });
  page.on("console", async (msg) => {
    const text = msg.text();
    if (!text.startsWith("REACT_SCAN_REPORT")) {
      return;
    }
    const reportDataString = text.replace("REACT_SCAN_REPORT", "").trim();
    try {
      count = parseInt(reportDataString, 10);
    } catch {
      return;
    }
    const truncatedURL = truncateString(currentURL, 50);
    if (currentSpinner) {
      currentSpinner.message(
        kleur.dim(`Scanning: ${truncatedURL}${count ? ` (\xD7${count})` : ""}`)
      );
    }
  });
};
void init();
